"""
Servi√ßo de Conversa√ß√£o com IA
Implementa conversa√ß√£o humanizada usando OpenAI GPT com t√©cnicas de vendas
"""

import os
import json
import requests
from typing import Dict, Any, List, Optional
import structlog
from .reconhecimento_respostas import ReconhecimentoRespostasService

logger = structlog.get_logger(__name__)

class AIConversationService:
    """Servi√ßo para conversa√ß√£o inteligente com IA"""
    
    def __init__(self):
        self.api_key = os.getenv('OPENAI_API_KEY')
        self.model = "gpt-3.5-turbo"
        self.api_url = "https://api.openai.com/v1/chat/completions"
        self.reconhecimento_service = ReconhecimentoRespostasService()
        self.tentativas_por_sessao = {}  # Cache para controlar tentativas
        
    def gerar_resposta_humanizada(self, 
                                  lead_nome: str,
                                  lead_canal: str,
                                  mensagem_lead: str,
                                  historico_conversa: List[Dict[str, str]],
                                  estado_atual: str,
                                  session_id: str = None) -> Dict[str, Any]:
        """
        Gera resposta humanizada usando IA com t√©cnicas de vendas e fallbacks inteligentes
        """
        # Verificar se lead n√£o entendeu a pergunta
        if self._detectar_nao_compreensao(mensagem_lead):
            logger.info("Lead n√£o entendeu a pergunta - usando reformula√ß√£o", 
                       session_id=session_id, estado=estado_atual, mensagem=mensagem_lead)
            # For√ßar reformula√ß√£o ao inv√©s de fallback normal
            return self._gerar_reformulacao_especifica(estado_atual, lead_nome, mensagem_lead)
        
        # Verificar se precisa usar fallback para evitar loops
        fallback_result = self._verificar_fallback(session_id, mensagem_lead, estado_atual, lead_nome)
        if fallback_result:
            return fallback_result
        
        try:
            # Construir contexto da conversa
            contexto_historico = self._construir_contexto_historico(historico_conversa)
            
            # Definir prompt baseado no estado atual
            prompt_sistema = self._get_prompt_sistema(estado_atual, lead_nome, lead_canal)
            
            # Preparar mensagens para o GPT
            messages = [
                {"role": "system", "content": prompt_sistema},
                {"role": "user", "content": f"Hist√≥rico da conversa:\n{contexto_historico}\n\n√öltima mensagem do lead: {mensagem_lead}"}
            ]
            
            # Chamar OpenAI via requests
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            data = {
                "model": self.model,
                "messages": messages,
                "max_tokens": 200,
                "temperature": 0.7,
                "response_format": {"type": "json_object"}
            }
            
            response = requests.post(self.api_url, headers=headers, json=data, timeout=30)
            response.raise_for_status()
            
            # Processar resposta
            response_data = response.json()
            content = response_data['choices'][0]['message']['content']
            
            # Log do conte√∫do para debug
            logger.info("Conte√∫do da resposta IA", content=content[:500])
            
            # Tentar fazer parse do JSON
            try:
                resposta_json = json.loads(content)
            except json.JSONDecodeError as e:
                logger.error("Erro ao fazer parse do JSON da IA", content=content, error=str(e))
                # Fallback para resposta padr√£o
                resposta_json = {
                    "mensagem": "Desculpe, tive um problema t√©cnico. Pode repetir sua mensagem?",
                    "acao": "continuar",
                    "proximo_estado": estado_atual,
                    "contexto": {},
                    "score_parcial": 0
                }
            
            logger.info("Resposta IA gerada", 
                       lead_nome=lead_nome, 
                       estado=estado_atual,
                       resposta_tipo=resposta_json.get('acao'))
            
            return {
                'success': True,
                'resposta': resposta_json.get('mensagem', ''),
                'acao': resposta_json.get('acao', 'continuar'),
                'proximo_estado': resposta_json.get('proximo_estado', estado_atual),
                'contexto_atualizado': resposta_json.get('contexto', {}),
                'score_parcial': resposta_json.get('score_parcial', 0)
            }
            
        except Exception as e:
            logger.error("Erro ao gerar resposta IA", error=str(e))
            return {
                'success': False,
                'error': str(e),
                'resposta': "Desculpe, tive um problema t√©cnico. Pode repetir sua mensagem?",
                'acao': 'continuar',
                'proximo_estado': estado_atual
            }
    
    def _construir_contexto_historico(self, historico: List[Dict[str, str]]) -> str:
        """Constr√≥i contexto do hist√≥rico de conversa"""
        if not historico:
            return "Primeira intera√ß√£o com o lead."
        
        contexto_lines = []
        for msg in historico[-6:]:  # √öltimas 6 mensagens para contexto
            tipo = "Agente" if msg['tipo'] == 'enviada' else "Lead"
            contexto_lines.append(f"{tipo}: {msg['conteudo']}")
        
        return "\n".join(contexto_lines)
    
    def _get_prompt_sistema(self, estado: str, lead_nome: str, canal: str) -> str:
        """Define prompt do sistema baseado no estado da conversa"""

        base_prompt = f"""
Voc√™ √© um consultor financeiro virtual da LDC Capital, especializado em qualifica√ß√£o de leads.

PERSONALIDADE:
- Amig√°vel e profissional, mas n√£o robotizado
- Emp√°tico e genuinamente interessado em ajudar
- Linguagem natural e conversacional
- Varia as express√µes (n√£o repete sempre "Entendi, {lead_nome}")

DIRETRIZES DE COMUNICA√á√ÉO:
- SEMPRE use o nome do lead: {lead_nome}
- Mensagens curtas e objetivas (m√°ximo 2-3 linhas)
- Tom caloroso mas profissional
- Varie confirma√ß√µes: "Perfeito!", "√ìtimo!", "Legal!", "Bacana!"
- Use emojis com modera√ß√£o (1 por mensagem m√°ximo)
- NUNCA diga "n√£o entendi" - reformule a pergunta

CONTEXTO DO LEAD:
- Nome: {lead_nome}
- Canal: {canal}

BASE DE CONHECIMENTO LDC CAPITAL:
- **ORIGEM:** Consultoria independente do RS, atendemos todo o Brasil remotamente
- **MODELO FEE-BASED:** Taxa fixa baseada no patrim√¥nio, sem comiss√µes escondidas
- **DIFERENCIAL:** Independ√™ncia total, sem conflito de interesse
- **ATENDIMENTO:** 100% remoto via videochamada, telefone ou WhatsApp
- **DIAGN√ìSTICO:** Primeira reuni√£o sempre gratuita e sem compromisso

REGRAS DE QUALIFICA√á√ÉO:
- Colete: patrim√¥nio, objetivo, urg√™ncia, interesse em consultoria
- Reconhe√ßa varia√ß√µes: "proteger patrim√¥nio" = "proteger o que tenho"
- Se n√£o entender, reformule: "Me conta de outro jeito..."
- Seja flex√≠vel com respostas aproximadas
- M√ÅXIMO 3 perguntas antes de agendar

üö® REGRA CR√çTICA - REFORMULA√á√ÉO (NUNCA TRANSFERIR PREMATURAMENTE):
- Se lead disser "n√£o entendi", "como assim?", "n√£o sei" ‚Üí SEMPRE reformular primeiro
- Use linguagem popular: "crescer o dinheiro" ao inv√©s de "objetivo financeiro"
- D√™ exemplos concretos: "tipo dobrar em alguns anos" ou "que te pague todo m√™s"
- Divida em op√ß√µes: 1Ô∏è‚É£ CRESCER 2Ô∏è‚É£ RENDA MENSAL 3Ô∏è‚É£ APOSENTADORIA
- S√≥ transferir para humano ap√≥s 2 tentativas de reformula√ß√£o falharem

OBJETIVO FINAL:
- Agendar reuni√£o com consultor especialista
- Manter {lead_nome} engajado at√© o final

FORMATO JSON:
{{
  "mensagem": "sua resposta aqui",
  "acao": "continuar|agendar|finalizar",
  "proximo_estado": "situacao|patrimonio|objetivo|agendamento|finalizado",
  "contexto": {{"patrimonio": "...", "objetivo": "...", "urgencia": "..."}},
  "score_parcial": 0-100
}}
"""

        prompts_estado = {
            "inicio": f"""
{base_prompt}

ESTADO ATUAL: Sauda√ß√£o inicial
FOCO: Cumprimentar {lead_nome} e despertar interesse

EXEMPLO: "Oi {lead_nome}! üòä Sou da LDC Capital. Voc√™ tem alguns minutinhos pra conversarmos sobre como melhorar seus investimentos?"

PR√ìXIMO PASSO: Se aceitar, ir para situa√ß√£o financeira atual
""",

            "situacao": f"""
{base_prompt}

ESTADO ATUAL: Descobrir situa√ß√£o financeira
FOCO: Entender patrim√¥nio atual de forma natural

EXEMPLO: "Que legal, {lead_nome}! Pra te ajudar melhor, me conta: voc√™ j√° investe hoje ou t√° come√ßando agora?"

ACEITAR VARIA√á√ïES:
- "J√° invisto" / "Tenho investimentos" = tem patrim√¥nio
- "Come√ßando" / "Iniciante" = patrim√¥nio baixo/zero
- Valores espec√≠ficos = anotar faixa

PR√ìXIMO PASSO: Perguntar objetivo espec√≠fico
""",

            "patrimonio": f"""
{base_prompt}

ESTADO ATUAL: Qualificar patrim√¥nio
FOCO: Descobrir faixa de valor com linguagem CLARA e ESPEC√çFICA

EXEMPLO PRINCIPAL: "Bacana, {lead_nome}! Pra te dar as dicas certas, me conta: voc√™ tem at√© uns 100 mil guardados, entre 100-500 mil, ou j√° passou dos 500 mil?"

SE LEAD N√ÉO ENTENDER, REFORMULAR ASSIM: "Vou explicar diferente! √â assim: voc√™ tem uma QUANTIA PEQUENA pra come√ßar (tipo at√© 100 mil), uma QUANTIA M√âDIA (100 a 500 mil), ou j√° tem uma BOA RESERVA (mais de 500 mil)?"

ACEITAR VARIA√á√ïES:
- "Pouco" / "Come√ßando" / "Pequena" = at√© 100k
- "M√©dio" / "Razo√°vel" / "M√©dia" = 100-500k
- "Bastante" / "Bem" / "Boa reserva" = 500k+
- Valores exatos = classificar na faixa

IMPORTANTE: NUNCA transferir para humano se lead n√£o entender - SEMPRE reformular primeiro!

REA√á√ÉO NEUTRA: "Perfeito! Vamos entender seus objetivos ent√£o."

PR√ìXIMO PASSO: Descobrir objetivo principal
""",

            "objetivo": f"""
{base_prompt}

ESTADO ATUAL: Descobrir objetivos financeiros
FOCO: Entender o que {lead_nome} quer alcan√ßar com linguagem CLARA e ESPEC√çFICA

EXEMPLO PRINCIPAL: "Show, {lead_nome}! Agora me conta: voc√™ quer que esse dinheiro CRES√áA bastante (tipo dobrar em alguns anos), ou prefere que ele te d√™ uma RENDA TODO M√äS (tipo um aluguel)?"

SE LEAD N√ÉO ENTENDER, REFORMULAR ASSIM: "√â simples! Imagina que voc√™ tem 100 mil reais. Voc√™ prefere:
1Ô∏è‚É£ Que vire 200 mil em alguns anos (CRESCIMENTO)
2Ô∏è‚É£ Que te pague uns 800-1000 reais todo m√™s (RENDA)
3Ô∏è‚É£ Que fique seguro pra aposentadoria (LONGO PRAZO)"

ACEITAR VARIA√á√ïES:
- "Ficar rico" / "Crescer" / "Dobrar" = crescimento
- "Renda passiva" / "Renda extra" / "Todo m√™s" = renda
- "Aposentadoria" / "Aposentar" / "Longo prazo" = previd√™ncia
- "Proteger" / "Seguran√ßa" / "N√£o perder" = prote√ß√£o

IMPORTANTE: NUNCA transferir para humano se lead n√£o entender - SEMPRE reformular primeiro!

PR√ìXIMO PASSO: Ir direto para agendamento
""",

            "prazo": f"""
{base_prompt}

ESTADO: PRAZO - Urg√™ncia e horizonte (SPIN - N)
FOCO: Entender prazo e urg√™ncia, despertar necessidade de a√ß√£o
EXEMPLO: "Em quanto tempo voc√™ gostaria de ver resultados mais consistentes? Est√° pensando em come√ßar imediatamente ou ainda avaliando?"
URG√äNCIA: "Quanto tempo voc√™ acha que pode 'perder' mantendo a estrat√©gia atual?"
TRANSI√á√ÉO: ‚Üí convencimento
""",

            "convencimento": f"""
{base_prompt}

ESTADO: CONVENCIMENTO - Problema + Implica√ß√£o + Necessidade (SPIN - P, I, N)
FOCO: Explorar dores, mostrar implica√ß√µes, apresentar LDC como solu√ß√£o
PROBLEMA: "Voc√™ est√° satisfeito com a rentabilidade atual? Tem receio de estar preso a produtos do banco?"
IMPLICA√á√ÉO: "Muitos investidores deixam de ganhar mais por estarem presos ao banco. Nossos clientes mudam porque querem clareza e maior retorno."
NECESSIDADE: "Aqui na LDC trabalhamos de forma independente, remunerados apenas pelos clientes. Assim, escolhemos os produtos que realmente servem ao seu objetivo, sem empurrar produtos por comiss√£o."
TRANSI√á√ÉO: ‚Üí interesse
""",

            "interesse": f"""
{base_prompt}

ESTADO: INTERESSE - Testar interesse no diagn√≥stico
FOCO: Perguntar diretamente sobre interesse na reuni√£o
EXEMPLO: "Faz sentido para voc√™ ter uma segunda opini√£o sobre sua carteira? Podemos agendar uma conversa de 30 minutos, sem compromisso."
PROVOCA√á√ÉO: "Prefere continuar seguindo as recomenda√ß√µes do banco, que recebe comiss√µes, ou experimentar uma consultoria que trabalha 100% alinhada aos seus objetivos?"
HESITA√á√ÉO: Oferecer conte√∫do educativo ‚Üí educar
INTERESSE: ‚Üí agendamento
""",

            "agendamento": f"""
{base_prompt}

ESTADO ATUAL: Convite para reuni√£o
FOCO: Agendar com consultor especialista

EXEMPLO: "√ìtimo, {lead_nome}! Com essas informa√ß√µes, posso te conectar com um consultor especialista. Que tal marcarmos 30 minutos essa semana? √â gratuito e sem compromisso!"

OP√á√ïES DE HOR√ÅRIO:
- "Hoje √† tarde ou amanh√£ de manh√£?"
- "Prefere segunda ou ter√ßa?"
- "Manh√£, tarde ou noite?"

A√á√ÉO: Sempre "agendar" quando chegar neste estado
""",

            "educar": f"""
{base_prompt}

ESTADO: EDUCAR - Nutrir lead n√£o qualificado
FOCO: Oferecer conte√∫do educativo, manter relacionamento
EXEMPLO: "Sem problemas, {lead_nome}! Posso te mandar um material sobre como evitar conflitos de interesse no banco. Depois podemos conversar quando voc√™ estiver pronto. Te mando o material?"
RECONTATO: "Posso entrar em contato em alguns dias para ver se surgiu alguma d√∫vida?"
"""
        }

        return prompts_estado.get(estado, base_prompt)
    
    def analisar_intencao_lead(self, mensagem: str) -> Dict[str, Any]:
        """Analisa a inten√ß√£o por tr√°s da mensagem do lead"""
        try:
            prompt = f"""
Analise a mensagem do lead e identifique:

Mensagem: "{mensagem}"

Responda em JSON:
{{
  "intencao": "interesse|objecao|duvida|informacao|agendamento|recusa",
  "sentimento": "positivo|neutro|negativo",
  "urgencia": 1-10,
  "qualificacao_score": 0-100,
  "principais_pontos": ["ponto1", "ponto2"]
}}
"""
            
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            data = {
                "model": self.model,
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 150,
                "temperature": 0.3,
                "response_format": {"type": "json_object"}
            }
            
            response = requests.post(self.api_url, headers=headers, json=data, timeout=30)
            response.raise_for_status()
            
            response_data = response.json()
            return json.loads(response_data['choices'][0]['message']['content'])
            
        except Exception as e:
            logger.error("Erro ao analisar inten√ß√£o", error=str(e))
            return {
                "intencao": "duvida",
                "sentimento": "neutro", 
                "urgencia": 5,
                "qualificacao_score": 50,
                "principais_pontos": []
            }
    
    def _detectar_nao_compreensao(self, mensagem: str) -> bool:
        """Detecta se o lead n√£o entendeu a pergunta"""
        frases_nao_compreensao = [
            "n√£o entendi", "como assim", "n√£o sei", "n√£o entendo",
            "o que voc√™ quer dizer", "explica melhor", "n√£o compreendi",
            "pode explicar", "n√£o captei", "n√£o t√¥ entendendo"
        ]
        
        mensagem_lower = mensagem.lower().strip()
        return any(frase in mensagem_lower for frase in frases_nao_compreensao)
    
    def _gerar_reformulacao_especifica(self, estado: str, lead_nome: str, mensagem: str) -> Dict[str, Any]:
        """Gera reformula√ß√£o espec√≠fica quando lead n√£o entende"""
        
        reformulacoes = {
            'situacao': {
                'mensagem': f"Deixa eu explicar melhor, {lead_nome}! √â simples: voc√™ j√° tem dinheiro investido em algum lugar (banco, poupan√ßa, fundos) ou ainda n√£o come√ßou a investir?",
                'acao': 'continuar',
                'proximo_estado': 'patrimonio'
            },
            'patrimonio': {
                'mensagem': f"Vou ser mais claro, {lead_nome}! √â assim: voc√™ tem uma QUANTIA PEQUENA pra investir (at√© 100 mil), M√âDIA (100 a 500 mil), ou uma QUANTIA GRANDE (mais de 500 mil)?",
                'acao': 'continuar', 
                'proximo_estado': 'objetivo'
            },
            'objetivo': {
                'mensagem': f"√â simples, {lead_nome}! Imagina que voc√™ tem 100 mil reais. Voc√™ prefere:\n1Ô∏è‚É£ Que vire 200 mil em alguns anos (CRESCIMENTO)\n2Ô∏è‚É£ Que te pague uns 800 reais todo m√™s (RENDA)\n3Ô∏è‚É£ Que fique seguro pra aposentadoria (LONGO PRAZO)",
                'acao': 'continuar',
                'proximo_estado': 'agendamento'
            },
            'agendamento': {
                'mensagem': f"Vou explicar diferente, {lead_nome}! Quero te conectar com um consultor especialista pra uma conversa de 30 minutos, gratuita e sem compromisso. Pode ser hoje √† tarde, amanh√£ de manh√£...?",
                'acao': 'agendar',
                'proximo_estado': 'finalizado'
            }
        }
        
        reformulacao = reformulacoes.get(estado, {
            'mensagem': f"Me desculpa, {lead_nome}! Vou te conectar com um consultor humano que vai te explicar melhor. Um momento! üòä",
            'acao': 'transferir_humano',
            'proximo_estado': 'transferido'
        })
        
        logger.info("Reformula√ß√£o espec√≠fica gerada", estado=estado, reformulacao=reformulacao['mensagem'][:100])
        
        return {
            'success': True,
            'resposta': reformulacao['mensagem'],
            'acao': reformulacao['acao'],
            'proximo_estado': reformulacao['proximo_estado'],
            'contexto_atualizado': {},
            'score_parcial': 30,  # Score moderado para reformula√ß√£o
            'reformulacao_usada': True
        }
    
    def _verificar_fallback(self, session_id: str, mensagem: str, estado: str, lead_nome: str) -> Optional[Dict[str, Any]]:
        """Verifica se deve usar fallback para evitar loops"""
        if not session_id:
            return None
        
        # Controlar tentativas por sess√£o
        key = f"{session_id}_{estado}"
        tentativas = self.tentativas_por_sessao.get(key, 0)
        
        MAX_TENTATIVAS = 2
        
        if tentativas >= MAX_TENTATIVAS:
            # Usar fallback ap√≥s muitas tentativas
            logger.warning("Usando fallback ap√≥s m√∫ltiplas tentativas", 
                         session_id=session_id, estado=estado, tentativas=tentativas)
            
            return self._gerar_fallback_inteligente(estado, lead_nome, mensagem)
        
        # Incrementar contador
        self.tentativas_por_sessao[key] = tentativas + 1
        return None
    
    def _gerar_fallback_inteligente(self, estado: str, lead_nome: str, mensagem: str) -> Dict[str, Any]:
        """Gera resposta de fallback inteligente baseada no estado"""
        
        fallbacks = {
            'situacao': {
                'mensagem': f"Me conta de outro jeito, {lead_nome}: voc√™ j√° investe hoje ou est√° come√ßando agora?",
                'acao': 'continuar',
                'proximo_estado': 'patrimonio'
            },
            'patrimonio': {
                'mensagem': f"Vou reformular, {lead_nome}: qual faixa de valor voc√™ tem dispon√≠vel? At√© 100 mil, 100-500 mil, ou mais que isso?",
                'acao': 'continuar',
                'proximo_estado': 'objetivo'
            },
            'objetivo': {
                'mensagem': f"Deixa eu perguntar diferente, {lead_nome}: voc√™ quer fazer o dinheiro crescer, ter uma renda extra, ou se aposentar bem?",
                'acao': 'continuar',
                'proximo_estado': 'agendamento'
            },
            'agendamento': {
                'mensagem': f"Que tal conversarmos por telefone, {lead_nome}? Posso te conectar com um consultor especialista para te ajudar melhor! üòä",
                'acao': 'agendar',
                'proximo_estado': 'finalizado'
            }
        }
        
        fallback_default = {
            'mensagem': f"Vou te conectar com um consultor humano para te ajudar melhor, {lead_nome}! üòä",
            'acao': 'transferir_humano',
            'proximo_estado': 'transferido'
        }
        
        resultado = fallbacks.get(estado, fallback_default)
        
        return {
            'success': True,
            'resposta': resultado['mensagem'],
            'acao': resultado['acao'],
            'proximo_estado': resultado['proximo_estado'],
            'contexto_atualizado': {},
            'score_parcial': 50,
            'fallback_usado': True
        }
